# Retrospective — Epic 5 : Communication & Notifications

**Date :** 2026-02-19
**Facilitateur :** Bob (Scrum Master)
**Projet :** BookMi_v2 — Marketplace de réservation de talents en Côte d'Ivoire
**Stack :** Laravel 12 backend + Flutter 3 mobile + FCM push notifications + WebSockets (Laravel Reverb/Pusher)

---

## Metriques de l'Epic

| Indicateur               | Valeur                                                     |
| ------------------------ | ---------------------------------------------------------- |
| Stories planifiees       | 7                                                          |
| Stories livrees (done)   | 7                                                          |
| Taux de completion       | 100 %                                                      |
| Tests backend (feature)  | 5-1: 14 tests / 5-2: 16 tests / 5-4: 9 tests / 5-6: 5 tests |
| Tests backend (unit)     | 5-2: 14 tests / 5-3: 7 tests / 5-5: 6 tests               |
| Tests Flutter            | 5-7: 6 tests (messaging_cubit_test)                        |
| Criteres d'acceptance    | 31 AC valides sur 7 stories                                |
| Migrations livrees       | 6 migrations (conversations, messages, auto_reply, fcm_token, push_notifications) |
| Nouveaux services        | MessagingService, ContactDetectionService, FcmService      |
| Nouveaux jobs / commandes | SendPushNotification (job), SendReminderNotifications (command) |

---

## Ceremonie — Tour de table retrospective

---

### Bob (Scrum Master):

Bienvenue a la retrospective de l'Epic 5 — Communication & Notifications. C'est un epic majeur : nous avons livré la colonne vertébrale de l'engagement utilisateur sur BookMi. Messagerie temps réel, push FCM, rappels automatisés, protection anti-désintermédiation, réponses automatiques et accès admin en cas de litige. Sept stories, sept done. C'est une livraison propre. Passons en revue ce qui a marché, ce qui nous a coûté, et ce que nous emportons pour la suite.

---

## Ce qui a bien fonctionne (Keep)

### Bob (Scrum Master):

**1. Architecture "single entry point" de la messagerie**

Le choix de centraliser toute la logique dans `MessagingService` s'est révélé payant. Chaque story qui a suivi (auto-reply 5-3, detection 5-2, push FCM 5-4) s'est greffée proprement sur `sendMessage()` sans casser les stories précédentes. La composition de services a tenu la route.

**2. 100 % de couverture des Acceptance Criteria**

Chaque AC a son test feature ou unit associé. Quand un AC était ambigu (ex: "une seule auto-reply par conversation"), le test a forcé la décision d'implémentation avant le code. TDD au sens utile du terme.

**3. Graceful degradation FCM**

Décision excellente : si `FCM_SERVER_KEY` n'est pas configuré, le job log et sort sans exception. Ça signifie que les environnements de dev et de staging fonctionnent sans credentiel FCM réel. Zéro blocage pour l'équipe QA.

---

### Alice (Product Owner):

**4. La détection anti-désintermédiation n'est pas bloquante — elle est pédagogique**

J'avais initialement demandé de bloquer les messages contenant des coordonnées. L'équipe a proposé une meilleure solution : envoyer le message mais le flaguer et retourner un avertissement (`CONTACT_SHARING_DETECTED`). L'utilisateur est averti, le message est envoyé, et l'admin peut instruire en cas de litige via 5-6. C'est beaucoup plus respectueux de l'UX et juridiquement plus solide.

**5. Les rappels J-7 / J-2 avec `--dry-run`**

Le mode `--dry-run` sur la commande `bookmi:send-reminders` est une fonctionnalité que je n'avais pas demandée explicitement mais que l'équipe a livrée. En production, avant d'activer le scheduler, on peut simuler une exécution et voir exactement quels bookings seraient notifiés. C'est le genre de pragmatisme qui évite des incidents en prod.

**6. L'audit trail admin (5-6)**

L'événement `AdminAccessedMessages` dispatché à chaque consultation admin de messages de litige crée une traçabilité complète. Si un admin consulte abusivement des messages, on le sait. C'était une exigence implicite de conformité qui a été capturée et livrée.

---

### Charlie (Senior Dev):

**7. La contrainte unique DB sur `(client_id, talent_profile_id)` dans `conversations`**

Utiliser `firstOrCreate` couplé a une contrainte unique en base pour éviter les doublons de conversations est la bonne approche. Même sous charge concurrente, le `firstOrCreate` avec la contrainte DB évite les race conditions. Et la transaction dans `MessageController::store()` garantit qu'une conversation ne peut pas exister sans son premier message.

**8. L'inversion `toOthers()` — décision pragmatique**

On a retiré `broadcast()->toOthers()` car le socket ID n'est pas toujours transmis depuis le mobile Flutter. A la place, le client filtre les messages par `sender_id` pour éviter les doublons d'affichage. C'est une simplification architecturale qui evite un vrai problème de timing sur mobile.

**9. Le pattern `ShouldBroadcast` + `ShouldQueue` bien séparés**

`MessageSent` broadcast (WebSocket) et `SendPushNotification` queue (FCM) sont deux mécanismes indépendants. Si le WebSocket est indisponible, le push FCM arrive quand même. Si FCM est indisponible, le WebSocket fonctionne. Résilience par design.

---

### Dana (QA Engineer):

**10. Les factories avec états (`read`, `flagged`, `autoReply`)**

Les factories `ConversationFactory` et `MessageFactory` avec états nommés ont rendu les tests feature extrêmement lisibles. On crée un message `$message->flagged()` et on sait exactement ce qu'on teste. Zéro ambiguïté dans les assertions.

**11. `Queue::fake()` sur les tests de dispatch**

Tester que `SendPushNotification` est dispatché sans exécuter réellement le job — c'est la bonne façon de tester les queues. Les tests sont déterministes, rapides, et ne nécessitent pas de Redis ou de worker en environnement CI.

---

### Elena (Junior Dev):

**12. La couche BLoC Flutter est claire et testable**

Les sealed states (`MessagingInitial`, `MessagingLoading`, `ConversationsLoaded`, `MessagesLoaded`, `MessageSending`, `MessagingError`) couvrent tous les états possibles. Le test de séquence `[Loading, Loaded, Sending, Loaded]` pour `sendMessage` est un exemple de test BLoC bien structuré que je vais réutiliser comme template.

**13. L'UI des bulles flagguees**

Le fond orange + label "Coordonnées détectées" sur les messages flaggués et le badge "Réponse automatique" sur les auto-replies sont des détails UX qui rendent l'app professionnelle. L'utilisateur comprend ce qui se passe sans texte explicatif long.

---

## Ce qui a ete difficile (Challenges)

---

### Bob (Scrum Master):

**Challenge 1 — L'anti-désintermédiation : complexité des regex et faux positifs**

La story 5-2 a été la plus complexe à spécifier. Combien de patterns faut-il couvrir ? Comment éviter les faux positifs (ex: un numéro de commande qui ressemble à un numéro de téléphone) ? On a dû itérer sur les regex pour trouver le bon équilibre entre recall (détecter le maximum) et précision (ne pas flaguer à tort). Les 6 patterns finaux (phone, email, url, whatsapp, telegram, social) couvrent bien le périmètre ivoirien, mais le tuning en production sera nécessaire.

---

### Alice (Product Owner):

**Challenge 2 — Le setup FCM a ralenti le démarrage de 5-4**

La configuration FCM v1 (HTTP v1 API, pas la legacy API dépréciée) nécessite un `project_id` et un `server_key` issus de la Firebase Console. En l'absence de compte Firebase projet disponible en début de sprint, l'équipe a dû travailler avec des stubs pendant 2 jours avant d'avoir les vraies credentiels. La graceful degradation a compensé, mais le setup aurait dû être préparé en amont du sprint.

**Challenge 3 — La définition de "conversation liée à une réservation"**

Story 5-6 : initialement, `booking_request_id` est nullable sur `conversations`. Quand un client contacte un talent hors contexte de réservation, il n'y a pas de booking associé. L'admin dispute endpoint ne peut donc fonctionner que si la conversation est liée à une réservation. On a clarifié que c'est acceptable pour le MVP : les litiges instruisibles sont uniquement ceux liés à une réservation. La conversation "hors booking" ne peut pas être instruite via ce endpoint.

---

### Charlie (Senior Dev):

**Challenge 4 — WebSockets en contexte mobile Flutter (reconnexion)**

Pusher/Reverb sur mobile Flutter pose un problème spécifique : lorsque l'app passe en arrière-plan, la connexion WebSocket est fermée par l'OS. La reconnexion automatique à la reprise n'est pas triviale. Dans la story 5-7, on a choisi de ne pas gérer la reconnexion WebSocket temps réel dans ce sprint : l'utilisateur doit pull-to-refresh pour voir les nouveaux messages si l'app était en arrière-plan. La connexion temps réel fonctionne quand l'app est en foreground. C'est une dette technique explicite.

**Challenge 5 — L'ordre des messages et la pagination**

`getMessages()` pagine DESC (du plus récent au plus ancien) mais la `ChatPage` Flutter doit afficher oldest-first. Le `MessagingCubit::loadMessages()` inverse les messages (`messages.reversed`) après réception. C'est fonctionnel mais cela signifie qu'on charge et renverse en mémoire. Sur des conversations très longues (> 1000 messages), cela pourrait poser un problème de mémoire. Le système de pagination infinie côté Flutter n'est pas implémenté.

---

### Dana (QA Engineer):

**Challenge 6 — Tester le broadcast WebSocket en feature tests**

`Event::assertDispatched(MessageSent)` valide que l'événement est dispatché, mais pas que le broadcast WebSocket atteint réellement le client. Les tests feature ne testent pas le transport WebSocket — ils testent uniquement la logique d'application. On n'a pas de test end-to-end sur le WebSocket en CI. C'est une lacune connue.

---

### Elena (Junior Dev):

**Challenge 7 — Comprendre la cascade `sendMessage → maybeAutoReply → sendMessage`**

La récursion contrôlée dans `MessagingService` (sendMessage appelle maybeAutoReply qui rappelle sendMessage avec `isAutoReply: true`) était difficile à comprendre au premier abord. Le guard `!$isAutoReply` est le seul verrou anti-boucle infinie. Si on oublie ce flag dans un futur refactoring, on crée un stack overflow. Ce pattern mérite une documentation inline plus explicite.

---

## Lecons apprises

---

### Bob (Scrum Master):

**Lecon 1 — Préparer les credentials de services tiers avant le sprint**

FCM, Reverb/Pusher, Sentry : tout service tiers nécessitant un compte ou une clé API doit être configuré avant le premier jour du sprint. La tâche de setup n'est pas une user story, c'est un prérequis. A partir de l'Epic 6, on ajoute une "Definition of Ready" explicite qui inclut : "Les credentials des services tiers nécessaires sont disponibles dans le coffre-fort secrets."

**Lecon 2 — Documenter les décisions d'architecture comme des ADR (Architecture Decision Records)**

Le choix de retirer `toOthers()`, le choix de ne pas bloquer les messages flaggués, le choix de rendre `booking_request_id` nullable — chacune de ces décisions a été prise après discussion et est logiquement solide. Mais si un nouveau développeur arrive, il ne comprendra pas pourquoi. A partir de maintenant, chaque décision non-triviale dans les implementation notes doit être accompagnée d'une section "Pourquoi cette décision" (format ADR light).

**Lecon 3 — Les regex de détection doivent etre versionées et testées avec des corpus réels**

Les patterns de `ContactDetectionService` ont été écrits et testés avec des cas synthétiques. En production, les utilisateurs ivoiriens vont utiliser des formats de numéros que nous n'avons pas anticipés (ex: numéros Orange CI avec préfixes régionaux, numéros WhatsApp Business, etc.). Le service doit pouvoir recevoir de nouveaux patterns via configuration (`.env` ou table DB) sans redéploiement. C'est un item de dette technique a traiter à l'Epic 6 ou 7.

**Lecon 4 — L'optimistic UI BLoC doit etre accompagné d'un rollback**

`MessagingCubit::sendMessage()` affiche le message immédiatement avant confirmation du serveur (optimistic UI). Si le serveur retourne une erreur 422 ou 500, le message affiché doit disparaître (rollback). Dans l'implémentation actuelle (5-7), le state passe en `MessagingError` mais le message optimiste reste visible dans la liste si l'erreur arrive après le state `MessagesLoaded`. Il faudra ajouter un mécanisme de rollback explicite.

**Lecon 5 — Tester le scheduler avec des dates controlees (Carbon::setTestNow)**

Les tests de `SendReminderNotificationsTest` utilisent `Carbon::setTestNow()` pour simuler une date spécifique et tester les fenêtres J-7 / J-2. Ce pattern — figer le temps dans les tests — est la bonne pratique et doit être utilisé systématiquement dans tous les tests qui dépendent de la date courante (rappels, expiration de tokens, etc.). On documente ce pattern dans le README de tests du projet.

---

## Dette technique identifiee

| # | Description                                               | Priorité | Epic cible |
|---|-----------------------------------------------------------|----------|------------|
| DT-5-01 | Reconnexion WebSocket automatique sur mobile (background/foreground) | Haute | Epic 7 (ou post-MVP) |
| DT-5-02 | Pagination infinie côté Flutter pour les longues conversations | Moyenne | Epic 7 |
| DT-5-03 | Patterns de détection contact configurables sans redéploiement | Moyenne | Epic 6-7 |
| DT-5-04 | Rollback optimistic UI en cas d'erreur d'envoi message | Haute | Epic 6 (5-7 hotfix) |
| DT-5-05 | Tests E2E WebSocket broadcast (pas de couverture CI actuellement) | Basse | Post-MVP |
| DT-5-06 | Documentation inline "Pourquoi" dans MessagingService (récursion auto-reply) | Basse | Prochaine PR |
| DT-5-07 | FCM : migrer vers OAuth2 Service Account (plus robuste que server key) | Moyenne | Epic 7 |

---

## Action items

| # | Action                                                                 | Responsable | Echeance     |
|---|------------------------------------------------------------------------|-------------|--------------|
| AI-5-01 | Créer le ticket DT-5-04 (rollback optimistic UI) et l'ajouter au backlog Epic 6 | Elena | 2026-02-20 |
| AI-5-02 | Ajouter "credentials tiers disponibles" à la Definition of Ready officielle du projet | Bob | 2026-02-20 |
| AI-5-03 | Documenter le pattern `Carbon::setTestNow` dans `bookmi/tests/README.md` | Dana | 2026-02-21 |
| AI-5-04 | Créer les ADR pour les 3 décisions majeures de l'Epic 5 (toOthers, flagging non-bloquant, booking_request_id nullable) | Charlie | 2026-02-21 |
| AI-5-05 | Évaluer la migration FCM server key → Service Account OAuth2 (spike 1h) | Charlie | 2026-02-24 |
| AI-5-06 | Ajouter inline `// WHY:` comments dans `MessagingService::maybeAutoReply()` | Elena | Prochaine PR |
| AI-5-07 | Préparer les credentials Firebase (FCM) + Reverb pour le staging avant le début de l'Epic 6 | Aboubakarouattara | 2026-02-22 |

---

## Apercu Epic 6 — Suivi Jour J & Evaluation

---

### Alice (Product Owner):

L'Epic 6 est l'Epic de la confiance post-prestation. Une fois la prestation réalisée, la plateforme doit accompagner le client et le talent dans le suivi immédiat (check-in Jour J), puis la collecte d'avis (évaluation bidirectionnelle) et la gestion des litiges.

**Stories prévues :**

- **6-1 : Check-in Jour J (client confirme la présence du talent)**
  - Le client peut confirmer que la prestation a bien eu lieu via l'app le jour J
  - Déclenche la libération du paiement escrow vers le talent

- **6-2 : Évaluation client → talent**
  - Notation 1-5 étoiles + commentaire texte
  - Disponible uniquement après confirmation Jour J

- **6-3 : Évaluation talent → client**
  - Notation comportementale du client (sérieux, ponctualité, respect)
  - Utilisée pour modérer les clients problématiques

- **6-4 : Affichage des évaluations sur le profil talent**
  - Agrégat note moyenne, nombre d'avis, 5 derniers avis
  - Feed Flutter sur `TalentProfilePage`

- **6-5 : Gestion des litiges (client ou talent ouvre un litige)**
  - Workflow : ouvrir → admin instruit (avec 5-6 déjà prêt) → décision → clôture
  - Statut `disputed` sur `BookingRequest` déjà implémenté dans les épics précédents

- **6-6 : Tableau de bord admin litiges**
  - Liste des litiges ouverts, accès messages (5-6), décision admin, notification des parties

- **6-7 : Écrans Flutter Évaluation & Litige**
  - Formulaire d'évaluation post-prestation
  - Page de suivi de litige avec timeline

**Points d'attention pour Epic 6 :**
- Le rollback optimistic UI (DT-5-04) doit être résolu avant d'implémenter les évaluations Flutter
- L'accès admin aux messages (5-6) est le prérequis technique de 6-6 — il est déjà livré
- La libération du paiement escrow implique une intégration avec le module de paiement (Epic 4 déjà livré) — vérifier les interfaces

---

## Conclusion — Party mode

---

### Bob (Scrum Master):

Epic 5 — complet. 7 stories, 7 done. Aucune story reportée, aucun AC raté. L'équipe a livré la colonne vertébrale de la communication sur BookMi : les utilisateurs peuvent maintenant se parler en temps réel, recevoir des rappels avant leur prestation, et la plateforme se protège contre la désintermédiation. Ce n'est pas un sprint ordinaire — c'est l'Epic qui transforme BookMi d'une plateforme de réservation en une plateforme de communication.

### Alice (Product Owner):

Je veux souligner un point : on a livré des fonctionnalités complexes (WebSockets, FCM, scheduler cron, détection regex) sans une seule régression sur les épics précédents. C'est le signe d'une architecture saine et d'une équipe disciplinée. Les tests écrits lors des épics 1 à 4 nous ont protégés. L'investissement dans les tests paye maintenant.

### Charlie (Senior Dev):

`MessagingService` est le module dont je suis le plus fier de cet epic. Propre, composable, testable. Chaque story a pu y ajouter un comportement sans le réécrire. C'est le genre de code qu'on ne remarque pas parce qu'il fait exactement ce qu'il doit faire.

### Dana (QA Engineer):

59 tests livrés sur cet epic (backend + Flutter). Tous verts. La discipline "on teste les AC, pas l'implémentation" a rendu les tests stables. Quand on a refactorisé le `toOthers()`, aucun test n'a cassé parce que les tests testaient le comportement observable, pas le mécanisme interne.

### Elena (Junior Dev):

Mon premier BLoC complet avec états sealed, tests de séquence, et optimistic UI. J'ai appris plus sur la gestion d'états Flutter en une story que lors des 3 mois précédents. La ChatPage avec les bulles orange pour les messages flaggués et les badges robot pour les auto-replies, c'est moi. Je suis fière.

### Aboubakarouattara (Project Lead):

Epic 5 done. BookMi_v2 a maintenant une messagerie professionnelle, des notifications intelligentes, et une protection contre la désintermédiation. Ce sont des fonctionnalités que les vraies marketplaces mettent des années à affiner. Nous venons de les livrer. L'Epic 6 — Suivi Jour J & Evaluation — est le dernier bloc fonctionnel avant la bêta. On va le finir avec le même niveau d'exigence. Merci à toute l'équipe.

---

## Signatures

| Rôle                    | Nom                    | Date       |
|-------------------------|------------------------|------------|
| Scrum Master            | Bob                    | 2026-02-19 |
| Product Owner           | Alice                  | 2026-02-19 |
| Senior Developer        | Charlie                | 2026-02-19 |
| QA Engineer             | Dana                   | 2026-02-19 |
| Junior Developer        | Elena                  | 2026-02-19 |
| Project Lead            | Aboubakarouattara      | 2026-02-19 |

---

*Document genere le 2026-02-19 — BookMi_v2 Sprint Retrospective*
*Facilitateur : Bob (Scrum Master) — Format BMAD Party-Mode*
