# Retrospective — Epic 4 : Paiement & Sequestre

**Projet :** BookMi_v2 — Marketplace de reservation de talents en Cote d'Ivoire
**Epic :** 4 — Paiement & Sequestre (Escrow)
**Date :** 2026-02-19
**Sprint :** Sprint 4
**Animateur :** Bob (Scrum Master)

---

## Metriques du Sprint

| Metrique | Valeur |
|---|---|
| Stories planifiees | 10 |
| Stories terminees | 10 |
| Taux de completion | 100% |
| Tests ecrits (cumul suite) | 457 tests |
| Assertions (cumul suite) | 1 453 assertions |
| Tests Epic 4 (stories 4.1 a 4.10) | ~120 tests nouveaux |
| Regressions introduites | 0 |
| Code reviews issues resolues | 20+ (H, M, L) |

---

## La Seance

---

**Bob (Scrum Master):** Bon, l'equipe, prenez une respiration. Epic 4 est dans la boite — 10 stories, 10 done, zero regression. C'est pas anodin, parce que le paiement c'est litteralement la ou l'argent de nos talents circule. Aujourd'hui on fait notre retrospective au format party-mode : on dit ce qui a marche, ce qui a grince, on en tire des lecons concretes, et on regarde vers l'Epic 5. Alice, tu commences ?

---

**Alice (Product Owner):** Avec plaisir, Bob. Du cote metier, je suis vraiment satisfaite. L'objectif de l'Epic 4 etait de rendre la plateforme capable d'encaisser de l'argent de maniere fiable, de le proteger en sequestre, et de le verser au talent au bon moment. On a tout livre.

Ce qui m'a le plus impressionnee : le flow Mobile Money complet. Orange Money, Wave, MTN MoMo, Moov Money — quatre operateurs couverts en story 4.1. En Cote d'Ivoire, le Mobile Money c'est le mode de paiement dominant. On a pris la bonne decision de l'integrer en priorite plutot que de partir "carte bancaire first" comme on le ferait pour un produit europeen.

Le systeme de sequestre (story 4.4) est aussi une grande victoire produit. Le client paie, l'argent est bloque 48h apres livraison, le talent recoit son cachet seulement apres confirmation. Ca cree une relation de confiance des deux cotes : le talent sait qu'il sera paye, le client sait qu'il peut contester si necessaire. C'est exactement la promesse de valeur de BookMi.

---

**Charlie (Senior Dev):** Je vais etre honnete — j'etais stresse en debutant l'Epic 4. Le paiement c'est le domaine ou une race condition ou une idempotence ratee coute de l'argent reel. On a fait des choix d'architecture solides et je veux les documenter ici pour qu'ils servent de reference.

Premier choix critique : **l'appel HTTP Paystack sort de la DB::transaction** (story 4.1). Ca semble contre-intuitif au debut — pourquoi ne pas tout envelopper dans une transaction ? Parce que l'API Paystack peut prendre jusqu'a 15 secondes, et tenir une connexion MySQL ouverte 15s sous charge tue le pool. On cree la transaction en base (etat `initiated`), on libere la connexion, on appelle Paystack, on revient mettre a jour. Les tests couvrent le cas echec : la transaction est marquee `failed` et on re-throw l'exception.

Deuxieme choix : **`lockForUpdate()` systematique pour l'idempotence**. Dans le webhook handler (story 4.2), on recoit parfois le meme evenement deux fois parce que Paystack retente. Sans lock, deux workers paralleles pourraient creer deux `EscrowHold` pour la meme transaction. Le `lockForUpdate()` dans `DB::transaction` empeche ca : le deuxieme worker attend, voit le status `succeeded`, et skipee. Propre, atomique, testable.

Troisieme choix : **Decorator pattern pour le failover** (story 4.6). `PaymentGatewayResolver` encapsule Paystack + FedaPay. `PaymentService` ne sait pas qu'il y a un failover — il injecte `PaymentGatewayInterface` comme avant. Le basculement est transparent, loggue, et limite aux operations de collecte (le payout reste sur Paystack).

---

**Dana (QA Engineer):** Je reprends la parole sur les tests parce que c'est le domaine ou on a eu le plus de debats — et ou on a fait le plus de progres.

Les webhooks etaient le challenge numero un. Un webhook Paystack arrive de l'exterieur, sans contexte utilisateur, avec une signature HMAC-SHA512 a valider. Comment tester ca proprement ? On a mis en place `Http::preventStrayRequests()` dans tous les tests pour etre certains qu'aucun appel reseau reel ne s'echappe. On fake Paystack avec `Http::fake()` et on forge les payloads de webhook manuellement avec la signature correcte calculee en test.

Ce qui m'a pris du temps : tester l'**idempotence sous concurrence simulee**. On ne peut pas vraiment lancer deux workers en parallele dans PHPUnit. Notre solution : appeler deux fois le job `HandlePaymentWebhook::dispatchSync()` dans le meme test et asserter qu'il n'y a qu'un seul `EscrowHold` cree et qu'un seul evenement `PaymentReceived` dispatche. Ca couvre le cas sans vraiment simuler la parallelisation — c'est une limitation qu'on documente en dette technique.

Sur les 20+ issues corrigees lors des code reviews : 7 etaient de severite haute (H). Deux races conditions corrigees avec `lockForUpdate()`, une incoherence d'etat si le booking etait absent pendant le webhook handler (le `return` silencieux remplace par `throw RuntimeException` pour forcer le rollback). Ces corrections H ont ete les plus importantes de tout le sprint.

---

**Elena (Junior Dev):** De mon cote, j'ai pris en charge les stories 4.8 (dashboard financier talent) et 4.10 (ecran paiement Flutter), avec du support sur 4.3 (carte bancaire). Voila ce que j'emporte de ce sprint.

Sur Flutter (story 4.10), integrer le flow OTP Mobile Money en UI etait plus delicat que prevu. Le backend renvoie un `display_text` dans la `TransactionResource` — c'est le texte que Paystack veut qu'on affiche a l'utilisateur pour lui expliquer comment saisir son OTP (chaque operateur a un message different). Au debut j'avais hard-code les messages en Flutter. Charlie m'a montre pourquoi c'est une mauvaise idee : si Paystack change ses messages ou ajoute un operateur, il faut une mise a jour app store. En utilisant le `display_text` du backend, le contenu est dynamique et ne depend pas d'un release mobile.

Sur le dashboard financier (4.8), j'ai appris a utiliser les `WindowFunction` de MySQL via Eloquent pour calculer les cumuls. Les talents ont besoin de voir leur solde courant, leurs versements du mois, et leur solde en attente de liberation de sequestre. Trois chiffres, trois requetes bien indexees.

---

**Aboubakarouattara (Project Lead):** Merci a tous. Je veux prendre du recul sur ce qu'on vient d'accomplir.

L'Epic 4 est objectivement la plus risquee du projet. Un bug dans l'Epic 1 (profils) casse l'affichage. Un bug dans l'Epic 4 (paiement) peut doubler un prelevement, bloquer un sequestre indefiniment, ou verser de l'argent a tort. On savait que la marge d'erreur etait quasi-nulle.

Le fait qu'on livre 10/10 stories, 0 regression, avec un failover automatique vers FedaPay et un systeme de sequestre auditable, c'est une reussite d'equipe. La confiance que ca donne pour la suite est reelle.

Un point de satisfaction particulier : la decision de ne pas utiliser de SDK Paystack tiers. On utilise `Http::withToken()` directement. Ca nous garde en controle total des payloads, ca facilite les tests avec `Http::fake()`, et ca evite une dependance externe qui pourrait ne pas etre maintenue. Simple, testable, stable.

---

## Succes Majeurs

### 1. Integration Paystack Mobile Money (Story 4.1)
Quatre operateurs couverts (Orange Money, Wave, MTN MoMo, Moov Money). Architecture en 3 phases : validation synchrone, courte DB::transaction avec `lockForUpdate()`, appel HTTP hors transaction. Le flow OTP est pilote par le `display_text` Paystack retourne au client Flutter — design generique et resilient.

### 2. Idempotence des Webhooks (Story 4.2)
Validation HMAC-SHA512 timing-safe (`hash_equals`). Job `HandlePaymentWebhook` sur queue dediee `payments` avec 5 retries et backoff exponentiel (`[10, 30, 90, 270, 810]`s). `lockForUpdate()` dans `DB::transaction` elimine le TOCTOU sous webhooks concurrents. Event `PaymentReceived` dispatche APRES commit pour garantir la coherence des donnees pour les listeners.

### 3. Systeme de Sequestre (Story 4.4)
Liberation manuelle par le client (`POST /booking_requests/{booking}/confirm_delivery`) et liberation automatique nocturne (`artisan escrow:release-expired`, schedule 00:00 quotidien). `chunkById(100)` evite la saturation RAM. `EscrowReleased` event decouple l'EscrowService du PayoutService — Story 4.5 a juste enregistre un listener.

### 4. Failover Automatique (Story 4.6)
Pattern Decorator (`PaymentGatewayResolver`) : si Paystack renvoie `PAYMENT_GATEWAY_ERROR`, basculement transparent sur FedaPay pour la collecte. Les methodes Paystack-specifiques (`submitOtp`, `initiateTransfer`) ne basculent pas. `Log::warning` systematique sur chaque basculement pour l'observabilite ops.

### 5. Qualite du Code Review
20+ issues identifiees et corrigees avant merge : 2 races conditions critiques eliminee, 1 incoherence d'etat corrigee par rollback force, 3 verifications de propriete ajoutees (protection 403), couverture de test augmentee sur MTN MoMo, Moov Money et les cas limites de webhook.

---

## Challenges

### Challenge 1 : Complexite du flow Mobile Money Cote d'Ivoire
La Paystack Charge API pour le Mobile Money CI n'est pas un simple POST-et-attendre. Le flow est : initiation → `send_otp` → soumission OTP → webhook async. Chaque etape peut echouer independamment. Modeliser les etats de la `Transaction` (`initiated` → `processing` → `succeeded|failed`) et coordonner les trois endpoints API requis (`/payments/initiate`, `/payments/submit_otp`, `/webhooks/paystack`) a necessite plusieurs iterations de design avant d'etre satisfaisant.

### Challenge 2 : Tests de Webhooks Difficiles a Isoler
Les webhooks arrivent de l'exterieur, sans session utilisateur. Forger manuellement les payloads avec la signature HMAC correcte dans les tests est verbeux. L'absence d'un helper de test dedie (du genre `PaystackWebhookFaker`) a alenti l'ecriture des tests. On repetait du code de setup entre les 20 tests de webhook.

### Challenge 3 : Concurrence Simulee Non Reelle
L'idempotence sous vraie concurrence (deux workers PHP lisant et ecrivant simultanement) n'est pas testable avec PHPUnit standard. On a valide le comportement sequentiel (deux appels successifs) mais pas parallelise. Un test d'integration avec vraie concurrence necessiterait un outil externe (Pest parallelism ou test de charge k6).

### Challenge 4 : FedaPay API Differences
L'API FedaPay suit une logique differente de Paystack pour initialiser une transaction carte bancaire : deux appels HTTP successifs (POST `/transactions` puis GET `/transactions/{id}/token`). Adapter `FedaPayGateway` pour respecter le meme contrat que `PaymentGatewayInterface` a necessaire quelques allers-retours. Les methodes non supportees (`submitOtp`, `initiateTransfer`) lancent explicitement `PaymentException::unsupportedMethod()` plutot que de silencieusement echouer.

### Challenge 5 : Gestion des Variables d'Environnement Sandbox
Le projet maintient maintenant des cles sandbox et des cles production pour deux gateways (Paystack + FedaPay). La gestion de ces 6 variables d'env (`PAYSTACK_SECRET_KEY`, `PAYSTACK_PUBLIC_KEY`, `PAYSTACK_WEBHOOK_SECRET`, `FEDAPAY_SECRET_KEY`, `FEDAPAY_PUBLIC_KEY`) et leur rotation en environnement de staging a cree de la friction, notamment pour les developpeurs qui clonent le projet pour la premiere fois.

---

## Lecons Apprises

### Lecon 1 : Ne jamais tenir une connexion DB pendant un appel HTTP externe
L'appel HTTP Paystack dans une `DB::transaction` semblait plus simple mais aurait asphyxie le pool de connexions sous charge. La regle a retenir : creer l'enregistrement DB (commit), relacher la connexion, faire l'appel HTTP externe, revenir mettre a jour. Si l'appel externe echoue, on met a jour l'etat en echec. Pas de rollback magique possible — les effets de bord externes ne sont pas transactionnels.

### Lecon 2 : L'idempotence se valide DANS la transaction, pas avant
Verifier "est-ce que cette transaction existe deja ?" avant d'ouvrir `DB::transaction` cree un TOCTOU classique. Deux workers peuvent passer la verification simultanement, puis tous les deux creer un doublon. Le check doit etre fait APRES `lockForUpdate()`, a l'interieur de la transaction. Cette lecon s'applique a tout doublon metier : reservation, sequestre, payout.

### Lecon 3 : Dispatcher les Events APRES commit, jamais pendant
`EscrowReleased` et `PaymentReceived` sont dispatches apres que la `DB::transaction` est committee (`$wasReleased = true` par reference, `afterCommit`). Si on dispatche pendant la transaction, le listener peut lire des donnees pas encore visibles pour les autres connexions DB. La regle : les evenements metier sont des faits accomplis — on les envoie seulement quand le fait est committe en base.

### Lecon 4 : Le Decorator pattern preserve le Open/Closed Principle
Ajouter le failover FedaPay sans modifier `PaymentService`, ni `PayoutService`, ni les controllers : c'est le Decorator pattern applique a `PaymentGatewayInterface`. La lecon plus generale : quand on veut ajouter un comportement transversal (failover, logging, metriques, retry), envelopper l'interface existante plutot que modifier les services qui en dependent. Zero regression, zero changement de contrat.

### Lecon 5 : Un helper de test dedie pour les webhooks reduit la friction
On a repete du code HMAC de setup dans 20 tests de webhook. Une classe `WebhookTestHelper::buildPaystackPayload(string $event, array $data): array` avec signature correcte integree aurait reduit la friction et rendu les tests plus lisibles. A creer en debut d'Epic si d'autres webhooks sont ajoutes (Epic 5 : FCM, potentiels webhooks SMS).

---

## Dette Technique

| ID | Description | Priorite | Propose pour |
|---|---|---|---|
| DT-401 | Pas de test de concurrence reelle pour l'idempotence des webhooks — seulement sequentiel | Haute | Epic 5 ou test de charge dedie |
| DT-402 | Absence de `PaystackWebhookFaker` helper — code HMAC de setup repete dans 20 tests | Moyenne | Debut Epic 5 |
| DT-403 | `PAYSTACK_WEBHOOK_SECRET` absent → comportement de bypass avec `Log::warning` — acceptable en dev, risque en prod | Haute | Avant mise en production |
| DT-404 | FedaPay sandbox non integree dans le pipeline CI — tests FedaPayGateway mockes a 100% | Moyenne | Epic 6 ou avant prod |
| DT-405 | Rotation des cles API non documentee — procedure manuelle non formalisee pour les 6 variables d'env paiement | Basse | Runbook ops avant prod |
| DT-406 | `release_scheduled_at` fixe a +48h en dur dans le webhook handler — devrait etre configurable via `config/bookmi.php` | Basse | Epic 5 |
| DT-407 | Aucun monitoring specifique sur la queue `payments` — si le worker tombe, les webhooks s'accumulent silencieusement | Haute | Epic 8 (Monitoring) |

---

## Action Items

| # | Action | Responsable | Echeance |
|---|---|---|---|
| A-401 | Creer `PaystackWebhookTestHelper` dans `tests/Support/` | Dana | Semaine 1 Epic 5 |
| A-402 | Ajouter une alerte Sentry/Slack si `PAYSTACK_WEBHOOK_SECRET` est absent en production | Charlie | Avant deploy staging |
| A-403 | Configurer un health check sur la queue `payments` dans le dashboard ops | Charlie | Epic 8 |
| A-404 | Formaliser la procedure de rotation des cles Paystack et FedaPay dans le runbook ops | Aboubakarouattara | Avant mise en production |
| A-405 | Parametrer `release_scheduled_at` via `config/bookmi.php` (`escrow.auto_release_hours`) | Elena | Sprint 5 |
| A-406 | Evaluer un test de concurrence k6 pour l'idempotence webhook en staging | Dana | Epic 6 |

---

## Apercu Epic 5 : Communication & Notifications

L'Epic 5 "Communication & Notifications" couvre 7 stories :

- **5.1 — Messagerie interne temps reel** : Canal de messages entre client et talent dans le contexte d'une reservation. WebSockets via Laravel Reverb ou Pusher.
- **5.2 — Detection anti-desintermediation** : Analyse des messages pour detecter les tentatives de contourner la plateforme (partage de numeros de telephone, emails, reseaux sociaux).
- **5.3 — Reponses automatiques talent** : Templates de reponses rapides pour les talents tres sollicites.
- **5.4 — Notifications push FCM** : Notifications push Firebase Cloud Messaging pour les evenements cles (reservation acceptee, paiement recu, message entrant).
- **5.5 — Rappels automatiques J-7 et J-2** : Rappels automatiques avant la prestation pour reduire les no-shows.
- **5.6 — Acces admin messages en cas de litige** : Capacite pour l'admin de consulter les messages d'une reservation en litige (conformite, mediation).
- **5.7 — Ecran messagerie Flutter** : Interface mobile de la messagerie en temps reel.

**Ce que l'Epic 4 prepare pour l'Epic 5 :**
L'evenement `PaymentReceived` dispatche a la fin du webhook handler (story 4.2) est le declencheur naturel d'une notification push "Votre paiement a ete recu, la prestation est confirmee". Les listeners Epic 5 n'auront qu'a s'abonner a cet event. De meme, `EscrowReleased` pourra declencher "Votre cachet a ete verse sur votre compte Mobile Money". L'architecture evenementielle de l'Epic 4 rend l'Epic 5 plus simple a implementer.

**Point de vigilance :** Les webhooks FCM (push notifications delivrees ou echouees) suivront le meme pattern que les webhooks Paystack. Le `PaystackWebhookTestHelper` a creer en A-401 devrait etre concu de maniere generique (`WebhookTestHelper`) pour servir aussi les webhooks FCM.

---

## Conclusion

**Bob (Scrum Master):** Epic 4 terminee, 100% des stories done, zero regression, failover automatique en production, sequestre auditable. L'argent des talents de Cote d'Ivoire est protege par du code solide. L'equipe a delivre sur l'epic la plus critique du projet avec une rigueur exemplaire sur les races conditions, l'idempotence, et la couverture de tests.

On repart avec 7 dettes techniques identifiees, 6 action items assignes, et l'Epic 5 qui s'annonce moins risquee grace aux fondations posees en Epic 4.

Merci a Alice pour le cadrage produit serieux sur le Mobile Money CI, a Charlie pour les decisions d'architecture qui ont tenu la route, a Dana pour la rigueur sur les tests de webhook, a Elena pour la montee en competence sur les flows async et Flutter, et a Aboubakarouattara pour la confiance accordee a l'equipe.

Direction l'Epic 5.

---

*Document genere le 2026-02-19 par Bob (Scrum Master), BookMi_v2.*
*Format : Retrospective BMAD party-mode.*
